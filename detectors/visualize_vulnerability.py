#!/usr/bin/env python3
"""
Vulnerability Visualization Script

This script iterates through a dataset folder and generates vulnerability
visualizations for detectors that implement the `visualize_vulnerability` method.

Supports two dataset formats:
1. Simple format: Images in input_folder, optional masks in sibling 'masks' folder
2. Grid format (--grid): Parent folder with original/, samecat/, diffcat/, masks/, bboxs/

Usage:
    # Simple format
    python visualize_vulnerability.py --input_folder <path> --output_folder <path> [options]
    
    # Grid format for new dataset structure
    python visualize_vulnerability.py --data_folder <path> --output_folder <path> --grid [options]
    
Example:
    python visualize_vulnerability.py \
        --input_folder ./models/anomaly_ov/finetune_dataset/test/COCO_real \
        --output_folder ./vulnerability_visualizations \
        --detector AnomalyOV \
        --epsilon 0.05 \
        --top_k 0.5 \
        --noise_mode random
        
    # Grid format
    python visualize_vulnerability.py \
        --data_folder ./data/my_dataset \
        --output_folder ./vulnerability_grid \
        --detector AnomalyOV \
        --grid
"""

import os
import sys
import argparse
from typing import Optional, List

import torch
from tqdm import tqdm

# Setup paths
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
if SCRIPT_DIR not in sys.path:
    sys.path.insert(0, SCRIPT_DIR)

# Import detector utilities
from support.detect_utils import get_device


def get_detector_class(detector_name: str):
    """
    Dynamically load a detector class by name.
    
    Args:
        detector_name: Name of the detector (e.g., 'AnomalyOV')
        
    Returns:
        Detector class
    """
    # Mapping of detector names to their module paths
    DETECTOR_MAP = {
        'AnomalyOV': ('AnomalyOVDetector', os.path.join('models', 'anomaly_ov', 'detector.py')),
        'CLIP-D': ('CLIPDDetector', os.path.join('models', 'CLIP-D', 'detector.py')),
        'NPR': ('NPRDetector', os.path.join('models', 'NPR', 'detector.py')),
        'R50_nodown': ('R50NodownDetector', os.path.join('models', 'R50_nodown', 'detector.py')),
        'R50_TF': ('R50TFDetector', os.path.join('models', 'R50_TF', 'detector.py')),
        'P2G': ('P2GDetector', os.path.join('models', 'P2G', 'detector.py')),
    }
    
    if detector_name not in DETECTOR_MAP:
        available = ', '.join(DETECTOR_MAP.keys())
        raise ValueError(f"Unknown detector: {detector_name}. Available: {available}")
    
    class_name, module_path = DETECTOR_MAP[detector_name]
    full_path = os.path.join(SCRIPT_DIR, module_path)
    
    # Dynamic import
    import importlib.util
    spec = importlib.util.spec_from_file_location(detector_name, full_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules[detector_name] = module
    spec.loader.exec_module(module)
    
    return getattr(module, class_name)


def get_available_detectors() -> List[str]:
    """Return list of available detector names."""
    return ['AnomalyOV', 'CLIP-D', 'NPR', 'R50_nodown', 'R50_TF', 'P2G']


def parse_detector_weights(weights_str: str) -> dict:
    """
    Parse detector weights specification string.
    
    Format: "detector1:path1,detector2:path2" or just "path" for single detector
    
    Args:
        weights_str: Weights specification string
        
    Returns:
        Dictionary mapping detector names to weight paths
    """
    if not weights_str:
        return {}
    
    weights_dict = {}
    
    # Check if it's a simple path (no colons except for Windows drive letters)
    # or a detector:path specification
    if ':' not in weights_str or (len(weights_str) > 1 and weights_str[1] == ':' and weights_str[0].isalpha()):
        # Simple path - will be used for the single detector specified via --detector
        weights_dict['_default'] = weights_str
    else:
        # Parse detector:path pairs
        pairs = weights_str.split(',')
        for pair in pairs:
            pair = pair.strip()
            if not pair:
                continue
            
            # Handle Windows paths with drive letters (e.g., C:\path)
            if len(pair) > 2 and pair[1] == ':' and pair[0].isalpha():
                # Check if there's another colon after the drive letter
                rest = pair[2:]
                colon_idx = rest.find(':')
                if colon_idx == -1:
                    # No detector specified, just a path
                    weights_dict['_default'] = pair
                else:
                    # Format is like "AnomalyOV:C:\path" - but we need to find the first colon
                    # that's not part of the path
                    first_colon = pair.find(':')
                    detector_name = pair[:first_colon]
                    path = pair[first_colon + 1:]
                    weights_dict[detector_name] = path
            else:
                # Unix-style path or detector:path
                colon_idx = pair.find(':')
                if colon_idx == -1:
                    weights_dict['_default'] = pair
                else:
                    detector_name = pair[:colon_idx]
                    path = pair[colon_idx + 1:]
                    weights_dict[detector_name] = path
    
    return weights_dict


def list_images(folder: str) -> List[str]:
    """List all image files in a folder recursively."""
    exts = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp'}
    files = []
    for root, _, fnames in os.walk(folder):
        for f in fnames:
            if os.path.splitext(f)[1].lower() in exts:
                files.append(os.path.join(root, f))
    files.sort()
    return files


def find_mask_path(image_path: str, input_folder: str) -> Optional[str]:
    """
    Find the corresponding mask file for an image.
    
    The mask is expected to be in a 'masks' folder under the same parent
    as the input folder, with the same filename as the image.
    
    Args:
        image_path: Path to the input image
        input_folder: Path to the input folder
        
    Returns:
        Path to the mask file, or None if not found
    """
    # Get parent folder of input folder
    parent_folder = os.path.dirname(os.path.abspath(input_folder))
    masks_folder = os.path.join(parent_folder, 'masks')
    
    if not os.path.isdir(masks_folder):
        return None
    
    # Get the filename (relative path from input folder)
    rel_path = os.path.relpath(image_path, input_folder)
    
    # Try different extensions for the mask
    base_name = os.path.splitext(rel_path)[0]
    for ext in ['.png', '.jpg', '.jpeg', '.bmp', '.tiff']:
        mask_path = os.path.join(masks_folder, base_name + ext)
        if os.path.exists(mask_path):
            return mask_path
    
    return None


def main():
    parser = argparse.ArgumentParser(
        description='Generate vulnerability visualizations for detector models.',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Input options (mutually exclusive groups)
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument(
        '--input_folder', '-i',
        type=str,
        help='Input folder containing images to process (simple format)'
    )
    input_group.add_argument(
        '--data_folder',
        type=str,
        help='Parent data folder for grid format (contains original/, samecat/, diffcat/, masks/, bboxs/)'
    )
    
    parser.add_argument(
        '--output_folder', '-o',
        type=str,
        required=True,
        help='Output folder for saving visualizations'
    )
    parser.add_argument(
        '--grid',
        action='store_true',
        help='Enable grid visualization mode for new dataset format with original/samecat/diffcat/masks/bboxs'
    )
    parser.add_argument(
        '--detector', '-d',
        type=str,
        default='AnomalyOV',
        nargs='+',
        help='Detector(s) to use. Can specify multiple detectors separated by space (default: AnomalyOV)'
    )
    parser.add_argument(
        '--weights', '-w',
        type=str,
        default=None,
        help='Path to model weights. For multiple detectors, use format: "detector1:path1,detector2:path2". '
             'For a single detector, just provide the path.'
    )
    parser.add_argument(
        '--epsilon', '-e',
        type=float,
        default=0.05,
        help='Attack strength for adversarial perturbation (default: 0.05)'
    )
    parser.add_argument(
        '--top_k', '-k',
        type=float,
        default=0.5,
        help='Fraction of top anomaly regions to target (default: 0.5)'
    )
    parser.add_argument(
        '--noise_mode', '-n',
        type=str,
        default='random',
        choices=['random', 'structured', 'fgsm', 'pgd', 'deepfool'],
        help='Attack type (default: random)'
    )
    parser.add_argument(
        '--limit', '-l',
        type=int,
        default=0,
        help='Limit number of images to process (0 = no limit)'
    )
    parser.add_argument(
        '--device',
        type=str,
        default=None,
        help='Device to use (default: auto-detect)'
    )
    parser.add_argument(
        '--dpi',
        type=int,
        default=150,
        help='DPI for saved images (default: 150)'
    )
    parser.add_argument(
        '--overlay_alpha',
        type=float,
        default=0.4,
        help='Alpha for overlay in grid mode (default: 0.4)'
    )
    parser.add_argument(
        '--inpainted',
        action='store_true',
        help='Enable inpainted mode: load masks from a "masks" folder under the same parent '
             'as the input folder and compute metrics between maps and masks'
    )
    parser.add_argument(
        '--metrics_top_k',
        type=float,
        default=0.1,
        help='Top-k fraction for IoU metric computation (default: 0.1)'
    )
    
    args = parser.parse_args()
    
    # Validate arguments based on mode
    if args.grid:
        if args.data_folder is None:
            print("Error: --grid mode requires --data_folder")
            sys.exit(1)
        if not os.path.isdir(args.data_folder):
            print(f"Error: Data folder does not exist: {args.data_folder}")
            sys.exit(1)
        # Validate grid folder structure
        required_folders = ['original', 'samecat', 'diffcat', 'masks', 'bboxs']
        for folder in required_folders:
            folder_path = os.path.join(args.data_folder, folder)
            if not os.path.isdir(folder_path):
                print(f"Error: Required folder missing for grid mode: {folder_path}")
                sys.exit(1)
        print(f"Grid mode enabled. Data folder: {args.data_folder}")
    else:
        if args.input_folder is None:
            print("Error: Simple mode requires --input_folder")
            sys.exit(1)
        if not os.path.isdir(args.input_folder):
            print(f"Error: Input folder does not exist: {args.input_folder}")
            sys.exit(1)
    
    # Validate masks folder if inpainted mode (only for simple format)
    masks_folder = None
    if args.inpainted and not args.grid:
        parent_folder = os.path.dirname(os.path.abspath(args.input_folder))
        masks_folder = os.path.join(parent_folder, 'masks')
        if not os.path.isdir(masks_folder):
            print(f"Error: --inpainted mode enabled but masks folder not found: {masks_folder}")
            print(f"Expected masks folder under the parent of input folder: {parent_folder}")
            sys.exit(1)
        print(f"Inpainted mode enabled. Masks folder: {masks_folder}")
    
    # Get device
    if args.device:
        device = torch.device(args.device)
    else:
        device = get_device()
    print(f"Using device: {device}")
    
    # Parse weights specification
    weights_dict = parse_detector_weights(args.weights) if args.weights else {}
    
    # Normalize detector list (handle both single string and list)
    detector_names = args.detector if isinstance(args.detector, list) else [args.detector]
    
    # Load all detectors
    detectors = {}
    for detector_name in detector_names:
        print(f"Loading detector: {detector_name}")
        try:
            DetectorClass = get_detector_class(detector_name)
            detector = DetectorClass(device=device)
            
            # Get weights for this detector
            if detector_name in weights_dict:
                weights_path = weights_dict[detector_name]
            elif '_default' in weights_dict and len(detector_names) == 1:
                weights_path = weights_dict['_default']
            else:
                weights_path = None
            
            if weights_path:
                print(f"  Using weights: {weights_path}")
            else:
                print(f"  Using default weights")
            
            detector.load(weights_path)
            
            # Check if detector supports required methods
            if args.grid:
                if not hasattr(detector, 'visualize_vulnerability_grid'):
                    print(f"Warning: Detector {detector_name} does not have visualize_vulnerability_grid method, skipping")
                    continue
            else:
                if not hasattr(detector, 'visualize_vulnerability'):
                    print(f"Warning: Detector {detector_name} does not have visualize_vulnerability method, skipping")
                    continue
            
            detectors[detector_name] = detector
            
        except Exception as e:
            print(f"Error loading detector {detector_name}: {e}")
            import traceback
            traceback.print_exc()
            continue
    
    if not detectors:
        print("Error: No detectors were loaded successfully")
        sys.exit(1)
    
    print(f"\nLoaded {len(detectors)} detector(s): {', '.join(detectors.keys())}")
    
    # Get list of files to process
    if args.grid:
        # For grid mode, list files from the 'original' folder
        original_folder = os.path.join(args.data_folder, 'original')
        images = list_images(original_folder)
        # Extract just filenames for grid mode
        filenames = [os.path.basename(img) for img in images]
    else:
        images = list_images(args.input_folder)
        filenames = None
    
    if args.limit > 0:
        if args.grid:
            filenames = filenames[:args.limit]
        else:
            images = images[:args.limit]
    
    num_files = len(filenames) if args.grid else len(images)
    if num_files == 0:
        folder = os.path.join(args.data_folder, 'original') if args.grid else args.input_folder
        print(f"No images found in {folder}")
        sys.exit(1)
    
    print(f"Found {num_files} images to process")
    
    # Create output folder
    os.makedirs(args.output_folder, exist_ok=True)
    
    # Process images with each detector
    total_successful = 0
    total_failed = 0
    
    for detector_name, detector in detectors.items():
        print(f"\n--- Processing with {detector_name} ---")
        successful = 0
        failed = 0
        masks_found = 0
        
        # Create detector-specific output subfolder if multiple detectors
        if len(detectors) > 1:
            detector_output = os.path.join(args.output_folder, detector_name)
        else:
            detector_output = args.output_folder
        os.makedirs(detector_output, exist_ok=True)
        
        if args.grid:
            # Grid mode processing
            for filename in tqdm(filenames, desc=f"{detector_name}"):
                try:
                    # Generate output filename
                    base_name = os.path.splitext(filename)[0]
                    output_path = os.path.join(detector_output, f"{base_name}_grid.png")
                    
                    # Ensure output subdirectory exists
                    os.makedirs(os.path.dirname(output_path) or '.', exist_ok=True)
                    
                    # Call detector's visualize_vulnerability_grid method
                    detector.visualize_vulnerability_grid(
                        filename=filename,
                        data_folder=args.data_folder,
                        output_path=output_path,
                        epsilon=args.epsilon,
                        top_k=args.top_k,
                        noise_mode=args.noise_mode,
                        dpi=args.dpi,
                        overlay_alpha=args.overlay_alpha,
                    )
                    
                    successful += 1
                    
                except NotImplementedError as e:
                    print(f"\nError: {e}")
                    print(f"Detector {detector_name} does not support grid visualization.")
                    failed += len(filenames) - successful - failed
                    break
                    
                except Exception as e:
                    print(f"\nFailed to process {filename}: {e}")
                    import traceback
                    traceback.print_exc()
                    failed += 1
                    continue
        else:
            # Simple mode processing
            for image_path in tqdm(images, desc=f"{detector_name}"):
                try:
                    # Generate output filename
                    rel_path = os.path.relpath(image_path, args.input_folder)
                    base_name = os.path.splitext(rel_path)[0]
                    output_path = os.path.join(detector_output, f"{base_name}_vuln.png")
                    
                    # Ensure output subdirectory exists
                    os.makedirs(os.path.dirname(output_path) or '.', exist_ok=True)
                    
                    # Find mask path if inpainted mode
                    mask_path = None
                    if args.inpainted:
                        mask_path = find_mask_path(image_path, args.input_folder)
                        if mask_path:
                            masks_found += 1
                    
                    # Call detector's visualize_vulnerability method
                    detector.visualize_vulnerability(
                        image=image_path,
                        output_path=output_path,
                        epsilon=args.epsilon,
                        top_k=args.top_k,
                        noise_mode=args.noise_mode,
                        mask_path=mask_path,
                        dpi=args.dpi,
                        metrics_top_k=args.metrics_top_k,
                    )
                    
                    successful += 1
                    
                except NotImplementedError as e:
                    print(f"\nError: {e}")
                    print(f"Detector {detector_name} does not support vulnerability visualization.")
                    failed += len(images) - successful - failed
                    break
                    
                except Exception as e:
                    print(f"\nFailed to process {image_path}: {e}")
                    import traceback
                    traceback.print_exc()
                    failed += 1
                    continue
        
        print(f"{detector_name}: {successful} successful, {failed} failed")
        if args.inpainted and not args.grid:
            print(f"  Masks found: {masks_found}/{successful}")
        total_successful += successful
        total_failed += failed
    
    # Summary
    print(f"\n{'='*50}")
    print(f"Processing complete!")
    print(f"  Total Successful: {total_successful}")
    print(f"  Total Failed: {total_failed}")
    print(f"  Output folder: {args.output_folder}")
    print(f"{'='*50}")


if __name__ == '__main__':
    main()
